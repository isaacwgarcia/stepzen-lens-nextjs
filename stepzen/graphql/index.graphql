"Blockchain data scalar type"
scalar BlockchainData

"Broadcast scalar id type"
scalar BroadcastId

"ChainId custom scalar type"
scalar ChainId

"collect module data scalar type"
scalar CollectModuleData

"Contract address custom scalar type"
scalar ContractAddress

"create handle custom scalar type"
scalar CreateHandle

"Cursor custom scalar type"
scalar Cursor

"Ens custom scalar type"
scalar Ens

"Ethereum address custom scalar type"
scalar EthereumAddress

"follow module data scalar type"
scalar FollowModuleData

"handle custom scalar type"
scalar Handle

"handle claim id custom scalar type"
scalar HandleClaimIdScalar

"Internal publication id custom scalar type"
scalar InternalPublicationId

"jwt custom scalar type"
scalar Jwt

"limit custom scalar type"
scalar LimitScalar

"Locale scalar type"
scalar Locale

"Markdown scalar type"
scalar Markdown

"mimetype custom scalar type"
scalar MimeType

"Nft ownership id type"
scalar NftOwnershipId

"Nonce custom scalar type"
scalar Nonce

"The notification id"
scalar NotificationId

"ProfileId custom scalar type"
scalar ProfileId

"proxy action scalar id type"
scalar ProxyActionId

"Publication id custom scalar type"
scalar PublicationId

"The publication tag"
scalar PublicationTag

"Publication url scalar type"
scalar PublicationUrl

"The reaction id"
scalar ReactionId

"reference module data scalar type"
scalar ReferenceModuleData

"Query search"
scalar Search

"Relayer signature"
scalar Signature

"Sources custom scalar type"
scalar Sources

"timestamp date custom scalar type"
scalar TimestampScalar

"The tx hash"
scalar TxHash

"The tx id"
scalar TxId

"UnixTimestamp custom scalar type"
scalar UnixTimestamp

"Url scalar type"
scalar Url

"Represents NULL values"
scalar Void

union CollectModule =
    FreeCollectModuleSettings
  | FeeCollectModuleSettings
  | LimitedFeeCollectModuleSettings
  | LimitedTimedFeeCollectModuleSettings
  | RevertCollectModuleSettings
  | TimedFeeCollectModuleSettings
  | UnknownCollectModuleSettings

union FeedItemRoot = Post | Comment

union FollowModule =
    FeeFollowModuleSettings
  | ProfileFollowModuleSettings
  | RevertFollowModuleSettings
  | UnknownFollowModuleSettings

union MainPostReference = Post | Mirror

union MentionPublication = Post | Comment

union MirrorablePublication = Post | Comment

union Notification =
    NewFollowerNotification
  | NewCollectNotification
  | NewCommentNotification
  | NewMirrorNotification
  | NewMentionNotification
  | NewReactionNotification

union ProfileMedia = NftImage | MediaSet

union ProxyActionStatusResultUnion =
    ProxyActionStatusResult
  | ProxyActionError
  | ProxyActionQueued

union Publication = Post | Comment | Mirror

union PublicationForSale = Post | Comment

union PublicationSearchResultItem = Post | Comment

union ReferenceModule =
    FollowOnlyReferenceModuleSettings
  | UnknownReferenceModuleSettings
  | DegreesOfSeparationReferenceModuleSettings

union RelayResult = RelayerResult | RelayError

union SearchResult = PublicationSearchResult | ProfileSearchResult

union TransactionResult = TransactionIndexedResult | TransactionError

enum ClaimStatus {
  ALREADY_CLAIMED
  CLAIM_FAILED
  NOT_CLAIMED
}

enum CollectModules {
  LimitedFeeCollectModule
  FeeCollectModule
  LimitedTimedFeeCollectModule
  TimedFeeCollectModule
  RevertCollectModule
  FreeCollectModule
  UnknownCollectModule
}

enum CustomFiltersTypes {
  GARDENERS
}

enum FeedEventItemType {
  POST
  COMMENT
  MIRROR
  COLLECT_POST
  COLLECT_COMMENT
  REACTION_POST
  REACTION_COMMENT
}

enum FollowModules {
  FeeFollowModule
  RevertFollowModule
  ProfileFollowModule
  UnknownFollowModule
}

enum NotificationTypes {
  MIRRORED_POST
  MIRRORED_COMMENT
  MENTION_POST
  MENTION_COMMENT
  COMMENTED_COMMENT
  COMMENTED_POST
  COLLECTED_POST
  COLLECTED_COMMENT
  FOLLOWED
  REACTION_POST
  REACTION_COMMENT
}

enum ProfileSortCriteria {
  CREATED_ON
  MOST_FOLLOWERS
  LATEST_CREATED
  MOST_POSTS
  MOST_COMMENTS
  MOST_MIRRORS
  MOST_PUBLICATION
  MOST_COLLECTS
}

enum ProxyActionStatusTypes {
  MINTING
  TRANSFERRING
  COMPLETE
}

enum PublicationContentWarning {
  NSFW
  SENSITIVE
  SPOILER
}

enum PublicationMainFocus {
  VIDEO
  IMAGE
  ARTICLE
  TEXT_ONLY
  AUDIO
  LINK
  EMBED
}

enum PublicationMetadataDisplayTypes {
  number
  string
  date
}

enum PublicationMetadataStatusType {
  NOT_FOUND
  PENDING
  METADATA_VALIDATION_FAILED
  SUCCESS
}

enum PublicationReportingFraudSubreason {
  SCAM
  IMPERSONATION
}

enum PublicationReportingIllegalSubreason {
  ANIMAL_ABUSE
  HUMAN_ABUSE
  VIOLENCE
  THREAT_INDIVIDUAL
  DIRECT_THREAT
}

enum PublicationReportingReason {
  SENSITIVE
  ILLEGAL
  FRAUD
  SPAM
}

enum PublicationReportingSensitiveSubreason {
  NSFW
  OFFENSIVE
}

enum PublicationReportingSpamSubreason {
  MISLEADING
  MISUSE_HASHTAGS
  UNRELATED
  REPETITIVE
  FAKE_ENGAGEMENT
  MANIPULATION_ALGO
  SOMETHING_ELSE
}

enum PublicationSortCriteria {
  TOP_COMMENTED
  TOP_COLLECTED
  TOP_MIRRORED
  CURATED_PROFILES
  LATEST
}

enum PublicationTypes {
  POST
  COMMENT
  MIRROR
}

enum ReactionTypes {
  UPVOTE
  DOWNVOTE
}

enum ReferenceModules {
  FollowerOnlyReferenceModule
  DegreesOfSeparationReferenceModule
  UnknownReferenceModule
}

enum RelayErrorReasons {
  REJECTED
  HANDLE_TAKEN
  EXPIRED
  WRONG_WALLET_SIGNED
  NOT_ALLOWED
}

enum SearchRequestTypes {
  PUBLICATION
  PROFILE
}

enum TagSortCriteria {
  MOST_POPULAR
  ALPHABETICAL
}

enum TimelineType {
  POST
  COMMENT
  MIRROR
  COLLECT_POST
  COLLECT_COMMENT
}

enum TransactionErrorReasons {
  REVERTED
}

input AchRequest {
  secret: String!
  ethereumAddress: EthereumAddress!
  handle: CreateHandle
  freeTextHandle: Boolean
  overrideTradeMark: Boolean!
  overrideAlreadyClaimed: Boolean!
}

input AllPublicationsTagsRequest {
  limit: LimitScalar
  cursor: Cursor
  sort: TagSortCriteria!
  "The App Id"
  source: Sources
}

input ApprovedModuleAllowanceAmountRequest {
  "The contract addresses for the module approved currencies you want to find information on about the user"
  currencies: [ContractAddress!]!
  collectModules: [CollectModules!] = []
  unknownCollectModules: [ContractAddress!] = []
  followModules: [FollowModules!] = []
  unknownFollowModules: [ContractAddress!] = []
  referenceModules: [ReferenceModules!] = []
  unknownReferenceModules: [ContractAddress!] = []
}

input BroadcastRequest {
  id: BroadcastId!
  signature: Signature!
}

input BurnProfileRequest {
  profileId: ProfileId!
}

"The challenge request"
input ChallengeRequest {
  "The ethereum address you want to login with"
  address: EthereumAddress!
}

input ClaimHandleRequest {
  id: HandleClaimIdScalar
  freeTextHandle: CreateHandle
  "The follow module"
  followModule: FollowModuleParams
}

input CollectModuleParams {
  "The collect empty collect module"
  freeCollectModule: FreeCollectModuleParams
  "The collect revert collect module"
  revertCollectModule: Boolean
  "The collect fee collect module"
  feeCollectModule: FeeCollectModuleParams
  "The collect limited fee collect module"
  limitedFeeCollectModule: LimitedFeeCollectModuleParams
  "The collect limited timed fee collect module"
  limitedTimedFeeCollectModule: LimitedTimedFeeCollectModuleParams
  "The collect timed fee collect module"
  timedFeeCollectModule: TimedFeeCollectModuleParams
  "A unknown collect module"
  unknownCollectModule: UnknownCollectModuleParams
}

input CollectProxyAction {
  freeCollect: FreeCollectProxyAction
}

input CreateCollectRequest {
  publicationId: InternalPublicationId!
  "The encoded data to collect with if using an unknown module"
  unknownModuleData: BlockchainData
}

input CreateMirrorRequest {
  "Profile id"
  profileId: ProfileId!
  "Publication id of what you want to mirror on remember if this is a comment it will be that as the id"
  publicationId: InternalPublicationId!
  "The reference module info"
  referenceModule: ReferenceModuleParams
}

input CreatePublicCommentRequest {
  "Profile id"
  profileId: ProfileId!
  "Publication id of what your comments on remember if this is a comment you commented on it will be that as the id"
  publicationId: InternalPublicationId!
  "The metadata uploaded somewhere passing in the url to reach it"
  contentURI: Url!
  "The collect module"
  collectModule: CollectModuleParams!
  "The reference module"
  referenceModule: ReferenceModuleParams
}

input CreatePublicPostRequest {
  "Profile id"
  profileId: ProfileId!
  "The metadata uploaded somewhere passing in the url to reach it"
  contentURI: Url!
  "The collect module"
  collectModule: CollectModuleParams!
  "The reference module"
  referenceModule: ReferenceModuleParams
}

input CreatePublicSetProfileMetadataURIRequest {
  "Profile id"
  profileId: ProfileId!
  "The metadata uploaded somewhere passing in the url to reach it"
  metadata: Url!
}

input CreateSetDefaultProfileRequest {
  "Profile id"
  profileId: ProfileId!
}

input CreateSetFollowModuleRequest {
  profileId: ProfileId!
  "The follow module info"
  followModule: FollowModuleParams!
}

input CreateSetFollowNFTUriRequest {
  profileId: ProfileId!
  "The follow NFT URI is the NFT metadata your followers will mint when they follow you. This can be updated at all times. If you do not pass in anything it will create a super cool changing NFT which will show the last publication of your profile as the NFT which looks awesome! This means people do not have to worry about writing this logic but still have the ability to customise it for their followers"
  followNFTURI: Url
}

input CreateToggleFollowRequest {
  profileIds: [ProfileId!]!
  enables: [Boolean!]!
}

input DefaultProfileRequest {
  ethereumAddress: EthereumAddress!
}

input DegreesOfSeparationReferenceModuleParams {
  "Applied to comments"
  commentsRestricted: Boolean!
  "Applied to mirrors"
  mirrorsRestricted: Boolean!
  "Degrees of separation"
  degreesOfSeparation: Int!
}

input DoesFollow {
  "The follower address remember wallets follow profiles"
  followerAddress: EthereumAddress!
  "The profile id"
  profileId: ProfileId!
}

input DoesFollowRequest {
  "The follower infos"
  followInfos: [DoesFollow!]!
}

input ExploreProfilesRequest {
  limit: LimitScalar
  cursor: Cursor
  timestamp: TimestampScalar
  sortCriteria: ProfileSortCriteria!
  customFilters: [CustomFiltersTypes!] = []
}

input ExplorePublicationRequest {
  limit: LimitScalar
  cursor: Cursor
  timestamp: TimestampScalar
  sortCriteria: PublicationSortCriteria!
  "The App Id"
  sources: [Sources!] = []
  "The publication types you want to query"
  publicationTypes: [PublicationTypes!]
  "If you want the randomizer off (default on)"
  noRandomize: Boolean
  "If you wish to exclude any results for profile ids"
  excludeProfileIds: [ProfileId!]
  metadata: PublicationMetadataFilters
  customFilters: [CustomFiltersTypes!] = []
}

input FeeCollectModuleParams {
  "The collect module amount info"
  amount: ModuleFeeAmountParams!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

input FeeFollowModuleParams {
  "The follow module amount info"
  amount: ModuleFeeAmountParams!
  "The follow module recipient address"
  recipient: EthereumAddress!
}

input FeeFollowModuleRedeemParams {
  "The expected amount to pay"
  amount: ModuleFeeAmountParams!
}

input FeedHighlightsRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile id"
  profileId: ProfileId!
  "The App Id"
  sources: [Sources!] = []
  metadata: PublicationMetadataFilters
}

input FeedRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile id"
  profileId: ProfileId!
  "Filter your feed to whatever you wish"
  feedEventItemTypes: [FeedEventItemType!] = [
    POST
    COMMENT
    MIRROR
    COLLECT_POST
    COLLECT_COMMENT
    REACTION_POST
    REACTION_COMMENT
  ]
  "The App Id"
  sources: [Sources!] = []
  metadata: PublicationMetadataFilters
}

input Follow {
  profile: ProfileId!
  followModule: FollowModuleRedeemParams
}

input FollowModuleParams {
  "The follower fee follower module"
  feeFollowModule: FeeFollowModuleParams
  "The profile follow module"
  profileFollowModule: Boolean
  "The revert follow module"
  revertFollowModule: Boolean
  "The empty follow module"
  freeFollowModule: Boolean
  "A unknown follow module"
  unknownFollowModule: UnknownFollowModuleParams
}

input FollowModuleRedeemParams {
  "The follower fee follower module"
  feeFollowModule: FeeFollowModuleRedeemParams
  "The profile follower module"
  profileFollowModule: ProfileFollowModuleRedeemParams
  "A unknown follow module"
  unknownFollowModule: UnknownFollowModuleRedeemParams
}

input FollowProxyAction {
  freeFollow: FreeFollowProxyAction
}

input FollowRequest {
  follow: [Follow!]!
}

input FollowerNftOwnedTokenIdsRequest {
  address: EthereumAddress!
  profileId: ProfileId!
}

input FollowersRequest {
  limit: LimitScalar
  cursor: Cursor
  profileId: ProfileId!
}

input FollowingRequest {
  limit: LimitScalar
  cursor: Cursor
  address: EthereumAddress!
}

input FraudReasonInputParams {
  reason: PublicationReportingReason!
  subreason: PublicationReportingFraudSubreason!
}

input FreeCollectModuleParams {
  "Follower only"
  followerOnly: Boolean!
}

input FreeCollectProxyAction {
  publicationId: InternalPublicationId!
}

input FreeFollowProxyAction {
  profileId: ProfileId!
}

input GenerateModuleCurrencyApprovalDataRequest {
  currency: ContractAddress!
  "Floating point number as string (e.g. 42.009837). The server will move its decimal places for you"
  value: String!
  collectModule: CollectModules
  unknownCollectModule: ContractAddress
  followModule: FollowModules
  unknownFollowModule: ContractAddress
  referenceModule: ReferenceModules
  unknownReferenceModule: ContractAddress
}

input GetPublicationMetadataStatusRequest {
  publicationId: InternalPublicationId
  txHash: TxHash
  txId: TxId
}

input GlobalProtocolStatsRequest {
  "Unix time from timestamp - if not supplied it will go from 0 timestamp"
  fromTimestamp: UnixTimestamp
  "Unix time to timestamp - if not supplied it go to the present timestamp"
  toTimestamp: UnixTimestamp
  "The App Id"
  sources: [Sources!]
}

input HasTxHashBeenIndexedRequest {
  "Tx hash.. if your using the broadcaster you should use txId due to gas price upgrades"
  txHash: TxHash
  "Tx id.. if your using the broadcaster you should always use this field"
  txId: TxId
}

input HidePublicationRequest {
  "Publication id"
  publicationId: InternalPublicationId!
}

input IllegalReasonInputParams {
  reason: PublicationReportingReason!
  subreason: PublicationReportingIllegalSubreason!
}

input InternalPublicationsFilterRequest {
  limit: LimitScalar
  cursor: Cursor
  "must be DD/MM/YYYY"
  fromDate: String!
  "must be DD/MM/YYYY"
  toDate: String!
  "The App Id"
  source: Sources!
  "The shared secret"
  secret: String!
}

input LimitedFeeCollectModuleParams {
  "The collect module limit"
  collectLimit: String!
  "The collect module amount info"
  amount: ModuleFeeAmountParams!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

input LimitedTimedFeeCollectModuleParams {
  "The collect module limit"
  collectLimit: String!
  "The collect module amount info"
  amount: ModuleFeeAmountParams!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

"The metadata attribute input"
input MetadataAttributeInput {
  "The display type"
  displayType: PublicationMetadataDisplayTypes
  "The trait type - can be anything its the name it will render so include spaces"
  traitType: String!
  "The value"
  value: String!
}

input ModuleFeeAmountParams {
  "The currency address"
  currency: ContractAddress!
  "Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal."
  value: String!
}

input MutualFollowersProfilesQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile id your viewing"
  viewingProfileId: ProfileId!
  "The profile id you want the result to come back as your viewing from"
  yourProfileId: ProfileId!
}

input NFTData {
  "Id of the nft ownership challenge"
  id: NftOwnershipId!
  "The signature"
  signature: Signature!
}

input NFTsRequest {
  limit: LimitScalar
  cursor: Cursor
  "Filter by owner address"
  ownerAddress: EthereumAddress!
  "Filter by contract address"
  contractAddress: ContractAddress
  "Chain Ids"
  chainIds: [ChainId!]!
}

input NftOwnershipChallenge {
  "ContractAddress for nft"
  contractAddress: ContractAddress!
  "Token id for NFT"
  tokenId: String!
  "Chain Id"
  chainId: ChainId!
}

input NftOwnershipChallengeRequest {
  "The wallet address which owns the NFT"
  ethereumAddress: EthereumAddress!
  nfts: [NftOwnershipChallenge!]!
}

input NotificationRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile id"
  profileId: ProfileId!
  "The profile id"
  notificationTypes: [NotificationTypes!] = [
    MIRRORED_POST
    MIRRORED_COMMENT
    MENTION_POST
    MENTION_COMMENT
    COMMENTED_COMMENT
    COMMENTED_POST
    COLLECTED_POST
    COLLECTED_COMMENT
    FOLLOWED
    REACTION_POST
    REACTION_COMMENT
  ]
  "The App Id"
  sources: [Sources!] = []
  metadata: PublicationMetadataFilters
  customFilters: [CustomFiltersTypes!] = []
}

input PendingApprovalFollowsRequest {
  limit: LimitScalar
  cursor: Cursor
}

input ProfileFollowModuleBeenRedeemedRequest {
  followProfileId: ProfileId!
  redeemingProfileId: ProfileId!
}

input ProfileFollowModuleRedeemParams {
  "The profile id to use to follow this profile"
  profileId: ProfileId!
}

input ProfileFollowRevenueQueryRequest {
  "The profile id"
  profileId: ProfileId!
}

input ProfileOnChainIdentityRequest {
  profileIds: [ProfileId!]!
}

input ProfilePublicationRevenueQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile id"
  profileId: ProfileId!
  "The App Id"
  sources: [Sources!] = []
  "The revenue types"
  types: [PublicationTypes!] = [COMMENT, MIRROR, POST]
  metadata: PublicationMetadataFilters
}

input ProfilePublicationsForSaleRequest {
  limit: LimitScalar
  cursor: Cursor
  "Profile id"
  profileId: ProfileId!
  "The App Id"
  sources: [Sources!] = []
  metadata: PublicationMetadataFilters
}

input ProfileQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile ids"
  profileIds: [ProfileId!]
  "The ethereum addresses"
  ownedBy: [EthereumAddress!]
  "The handles for the profile"
  handles: [Handle!]
  "The mirrored publication id"
  whoMirroredPublicationId: InternalPublicationId
}

input ProxyActionRequest {
  follow: FollowProxyAction
  collect: CollectProxyAction
}

"Publication metadata content waring filters"
input PublicationMetadataContentWarningFilter {
  "By default all content warnings will be hidden you can include them in your query by adding them to this array."
  includeOneOf: [PublicationContentWarning!]
}

"Publication metadata filters"
input PublicationMetadataFilters {
  "IOS 639-1 language code aka en or it and ISO 3166-1 alpha-2 region code aka US or IT aka en-US or it-IT. You can just filter on language if you wish."
  locale: Locale
  contentWarning: PublicationMetadataContentWarningFilter
  mainContentFocus: [PublicationMainFocus!] = [
    ARTICLE
    AUDIO
    VIDEO
    EMBED
    IMAGE
    LINK
    TEXT_ONLY
  ]
  tags: PublicationMetadataTagsFilter
}

"The metadata attribute output"
input PublicationMetadataMediaInput {
  item: Url!
  "This is the mime type of media"
  type: MimeType
  "The alt tags for accessibility"
  altTag: String
  "The cover for any video or audio you attached"
  cover: String
}

"Publication metadata tag filter"
input PublicationMetadataTagsFilter {
  "Needs to only match one of"
  oneOf: [String!]
  "Needs to only match all"
  all: [String!]
}

input PublicationMetadataV1Input {
  "The metadata version. (1.0.0 | 2.0.0)"
  version: String!
  "The metadata id can be anything but if your uploading to ipfs you will want it to be random.. using uuid could be an option!"
  metadata_id: String!
  " This is the appId the content belongs to"
  appId: Sources
  "A human-readable description of the item."
  description: Markdown
  "The content of a publication. If this is blank `media` must be defined or its out of spec"
  content: Markdown
  """
  This is the URL that will appear below the asset's image on OpenSea and others etc
        and will allow users to leave OpenSea and view the item on the site.
  """
  external_url: Url
  "Signed metadata to validate the owner"
  signatureContext: PublicationSignatureContextInput
  "Name of the item."
  name: String!
  " These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item."
  attributes: [MetadataAttributeInput!]!
  "legacy to support OpenSea will store any NFT image here."
  image: Url
  "This is the mime type of the image. This is used if your uploading more advanced cover images as sometimes ipfs does not emit the content header so this solves that"
  imageMimeType: MimeType
  " This is lens supported attached media items to the publication"
  media: [PublicationMetadataMediaInput!]
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV,
        and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
        Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas,
        WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.
  """
  animation_url: Url
}

input PublicationMetadataV2Input {
  "The metadata version. (1.0.0 | 2.0.0)"
  version: String!
  "The metadata id can be anything but if your uploading to ipfs you will want it to be random.. using uuid could be an option!"
  metadata_id: String!
  " This is the appId the content belongs to"
  appId: Sources
  "A human-readable description of the item."
  description: Markdown
  "The content of a publication. If this is blank `media` must be defined or its out of spec"
  content: Markdown
  """
  This is the URL that will appear below the asset's image on OpenSea and others etc
        and will allow users to leave OpenSea and view the item on the site.
  """
  external_url: Url
  "Signed metadata to validate the owner"
  signatureContext: PublicationSignatureContextInput
  "Name of the item."
  name: String!
  " These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item."
  attributes: [MetadataAttributeInput!]!
  "legacy to support OpenSea will store any NFT image here."
  image: Url
  "This is the mime type of the image. This is used if your uploading more advanced cover images as sometimes ipfs does not emit the content header so this solves that"
  imageMimeType: MimeType
  " This is lens supported attached media items to the publication"
  media: [PublicationMetadataMediaInput!]
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV,
        and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
        Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas,
        WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.
  """
  animation_url: Url
  "IOS 639-1 language code aka en or it and ISO 3166-1 alpha-2 region code aka US or IT aka en-US or it-IT"
  locale: Locale!
  "Ability to tag your publication"
  tags: [String!]
  "Ability to add a content warning"
  contentWarning: PublicationContentWarning
  "Main content focus that for this publication"
  mainContentFocus: PublicationMainFocus!
}

input PublicationQueryRequest {
  "The publication id"
  publicationId: InternalPublicationId
  "The tx hash"
  txHash: TxHash
}

input PublicationRevenueQueryRequest {
  "The publication id"
  publicationId: InternalPublicationId!
}

input PublicationSignatureContextInput {
  signature: String!
}

input PublicationsQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  "Profile id"
  profileId: ProfileId
  "Profile ids"
  profileIds: [ProfileId!]
  "The publication types you want to query"
  publicationTypes: [PublicationTypes!]
  "The publication id you wish to get comments for"
  commentsOf: InternalPublicationId
  "The App Id"
  sources: [Sources!] = []
  "The ethereum address"
  collectedBy: EthereumAddress
  "The publication id"
  publicationIds: [InternalPublicationId!]
  metadata: PublicationMetadataFilters
  customFilters: [CustomFiltersTypes!] = []
}

input ReactionFieldResolverRequest {
  "Profile id"
  profileId: ProfileId
}

input ReactionRequest {
  "Profile id to perform the action"
  profileId: ProfileId!
  "The reaction"
  reaction: ReactionTypes!
  "The internal publication id"
  publicationId: InternalPublicationId!
}

input RecommendedProfileOptions {
  "If you wish to turn ML off"
  disableML: Boolean = false
  "If you wish to shuffle the results"
  shuffle: Boolean = false
}

input ReferenceModuleParams {
  "The follower only reference module"
  followerOnlyReferenceModule: Boolean
  "A unknown reference module"
  unknownReferenceModule: UnknownReferenceModuleParams
  "The degrees of seperation reference module"
  degreesOfSeparationReferenceModule: DegreesOfSeparationReferenceModuleParams
}

"The refresh request"
input RefreshRequest {
  "The refresh token"
  refreshToken: Jwt!
}

input RelRequest {
  secret: String!
  ethereumAddress: EthereumAddress!
}

input ReportPublicationRequest {
  publicationId: InternalPublicationId!
  reason: ReportingReasonInputParams!
  additionalComments: String
}

input ReportingReasonInputParams {
  sensitiveReason: SensitiveReasonInputParams
  illegalReason: IllegalReasonInputParams
  fraudReason: FraudReasonInputParams
  spamReason: SpamReasonInputParams
}

input SearchQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  "The search term"
  query: Search!
  type: SearchRequestTypes!
  customFilters: [CustomFiltersTypes!] = []
  "The App Id"
  sources: [Sources!] = []
}

input SensitiveReasonInputParams {
  reason: PublicationReportingReason!
  subreason: PublicationReportingSensitiveSubreason!
}

input SetDispatcherRequest {
  "The profile id"
  profileId: ProfileId!
  "The dispatcher address - they can post, comment, mirror, set follow module, change your profile picture on your behalf, if left as none it will use the built in dispatcher address."
  dispatcher: EthereumAddress
  "If you want to enable or disable it"
  enable: Boolean
}

"The signed auth challenge"
input SignedAuthChallenge {
  "The ethereum address you signed the signature with"
  address: EthereumAddress!
  "The signature"
  signature: Signature!
}

input SingleProfileQueryRequest {
  "The profile id"
  profileId: ProfileId
  "The handle for the profile"
  handle: Handle
}

input SpamReasonInputParams {
  reason: PublicationReportingReason!
  subreason: PublicationReportingSpamSubreason!
}

input TimedFeeCollectModuleParams {
  "The collect module amount info"
  amount: ModuleFeeAmountParams!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

input TimelineRequest {
  limit: LimitScalar
  cursor: Cursor
  "The profile id"
  profileId: ProfileId!
  "The App Id"
  sources: [Sources!] = []
  "The timeline types you wish to include, if nothing passed in will bring back all"
  timelineTypes: [TimelineType!] = [
    COLLECT_COMMENT
    COLLECT_POST
    COMMENT
    POST
    MIRROR
  ]
  metadata: PublicationMetadataFilters
}

input TypedDataOptions {
  "If you wish to override the nonce for the sig if you want to do some clever stuff in the client"
  overrideSigNonce: Nonce!
}

input UnfollowRequest {
  profile: ProfileId!
}

input UnknownCollectModuleParams {
  contractAddress: ContractAddress!
  "The encoded data to submit with the module"
  data: BlockchainData!
}

input UnknownFollowModuleParams {
  contractAddress: ContractAddress!
  "The encoded data to submit with the module"
  data: BlockchainData!
}

input UnknownFollowModuleRedeemParams {
  "The encoded data to submit with the module"
  data: BlockchainData!
}

input UnknownReferenceModuleParams {
  contractAddress: ContractAddress!
  "The encoded data to submit with the module"
  data: BlockchainData!
}

input UpdateProfileImageRequest {
  profileId: ProfileId!
  "The url to the image if offline"
  url: Url
  "The nft data"
  nftData: NFTData
}

input ValidatePublicationMetadataRequest {
  metadatav1: PublicationMetadataV1Input
  metadatav2: PublicationMetadataV2Input
}

"The access request"
input VerifyRequest {
  "The access token"
  accessToken: Jwt!
}

input WhoCollectedPublicationRequest {
  limit: LimitScalar
  cursor: Cursor
  "Internal publication id"
  publicationId: InternalPublicationId!
}

input WhoReactedPublicationRequest {
  limit: LimitScalar
  cursor: Cursor
  "Internal publication id"
  publicationId: InternalPublicationId!
}

type ApprovedAllowanceAmount {
  currency: ContractAddress!
  module: String!
  contractAddress: ContractAddress!
  allowance: String!
}

"The Profile"
type Attribute {
  "The display type"
  displayType: String
  "The trait type - can be anything its the name it will render so include spaces"
  traitType: String
  "identifier of this attribute, we will update by this id "
  key: String!
  "Value attribute"
  value: String!
}

"The auth challenge result"
type AuthChallengeResult {
  "The text to sign"
  text: String!
}

"The authentication result"
type AuthenticationResult {
  "The access token"
  accessToken: Jwt!
  "The refresh token"
  refreshToken: Jwt!
}

type CanCommentResponse {
  result: Boolean!
}

type CanMirrorResponse {
  result: Boolean!
}

type ClaimableHandles {
  reservedHandles: [ReservedClaimableHandle!]!
  canClaimFreeTextHandle: Boolean!
}

type CollectedEvent {
  profile: Profile!
  timestamp: DateTime!
}

"The social comment"
type Comment {
  "The internal publication id"
  id: InternalPublicationId!
  "The profile ref"
  profile: Profile!
  "The publication stats"
  stats: PublicationStats!
  "The metadata for the post"
  metadata: MetadataOutput!
  "The on chain content uri could be `ipfs://` or `https`"
  onChainContentURI: String!
  "The date the post was created on"
  createdAt: DateTime!
  "The collect module"
  collectModule: CollectModule!
  "The reference module"
  referenceModule: ReferenceModule
  "ID of the source"
  appId: Sources
  "If the publication has been hidden if it has then the content and media is not available"
  hidden: Boolean!
  "The contract address for the collect nft.. if its null it means nobody collected yet as it lazy deployed"
  collectNftAddress: ContractAddress
  "The top level post/mirror this comment lives on"
  mainPost: MainPostReference!
  "Which comment this points to if its null the pointer too deep so do another query to find it out"
  commentOn: Publication
  "This will bring back the first comment of a comment and only be defined if using `publication` query and `commentOf`"
  firstComment: Comment
  "Who collected it, this is used for timeline results and like this for better caching for the client"
  collectedBy: Wallet
  reaction(request: ReactionFieldResolverRequest): ReactionTypes
  hasCollectedByMe: Boolean!
  canComment(profileId: ProfileId): CanCommentResponse!
  canMirror(profileId: ProfileId): CanMirrorResponse!
  mirrors(by: ProfileId): [InternalPublicationId!]!
}

"The create burn eip 712 typed data"
type CreateBurnEIP712TypedData {
  "The types"
  types: CreateBurnEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateBurnEIP712TypedDataValue!
}

"The create burn eip 712 typed data types"
type CreateBurnEIP712TypedDataTypes {
  BurnWithSig: [EIP712TypedDataField!]!
}

"The create burn eip 712 typed data value"
type CreateBurnEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  tokenId: String!
}

"The broadcast item"
type CreateBurnProfileBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateBurnEIP712TypedData!
}

"The broadcast item"
type CreateCollectBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateCollectEIP712TypedData!
}

"The collect eip 712 typed data"
type CreateCollectEIP712TypedData {
  "The types"
  types: CreateCollectEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateCollectEIP712TypedDataValue!
}

"The collect eip 712 typed data types"
type CreateCollectEIP712TypedDataTypes {
  CollectWithSig: [EIP712TypedDataField!]!
}

"The collect eip 712 typed data value"
type CreateCollectEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  pubId: PublicationId!
  data: BlockchainData!
}

"The broadcast item"
type CreateCommentBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateCommentEIP712TypedData!
}

"The create comment eip 712 typed data"
type CreateCommentEIP712TypedData {
  "The types"
  types: CreateCommentEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateCommentEIP712TypedDataValue!
}

"The create comment eip 712 typed data types"
type CreateCommentEIP712TypedDataTypes {
  CommentWithSig: [EIP712TypedDataField!]!
}

"The create comment eip 712 typed data value"
type CreateCommentEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  contentURI: PublicationUrl!
  profileIdPointed: ProfileId!
  pubIdPointed: PublicationId!
  collectModule: ContractAddress!
  collectModuleInitData: CollectModuleData!
  referenceModule: ContractAddress!
  referenceModuleInitData: ReferenceModuleData!
  referenceModuleData: ReferenceModuleData!
}

"The broadcast item"
type CreateFollowBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateFollowEIP712TypedData!
}

"The create follow eip 712 typed data"
type CreateFollowEIP712TypedData {
  "The types"
  types: CreateFollowEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateFollowEIP712TypedDataValue!
}

"The create follow eip 712 typed data types"
type CreateFollowEIP712TypedDataTypes {
  FollowWithSig: [EIP712TypedDataField!]!
}

"The create follow eip 712 typed data value"
type CreateFollowEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileIds: [ProfileId!]!
  datas: [BlockchainData!]!
}

"The broadcast item"
type CreateMirrorBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateMirrorEIP712TypedData!
}

"The mirror eip 712 typed data"
type CreateMirrorEIP712TypedData {
  "The types"
  types: CreateMirrorEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateMirrorEIP712TypedDataValue!
}

"The mirror eip 712 typed data types"
type CreateMirrorEIP712TypedDataTypes {
  MirrorWithSig: [EIP712TypedDataField!]!
}

"The mirror eip 712 typed data value"
type CreateMirrorEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  profileIdPointed: ProfileId!
  pubIdPointed: PublicationId!
  referenceModuleData: ReferenceModuleData!
  referenceModule: ContractAddress!
  referenceModuleInitData: ReferenceModuleData!
}

"The broadcast item"
type CreatePostBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreatePostEIP712TypedData!
}

"The create post eip 712 typed data"
type CreatePostEIP712TypedData {
  "The types"
  types: CreatePostEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreatePostEIP712TypedDataValue!
}

"The create post eip 712 typed data types"
type CreatePostEIP712TypedDataTypes {
  PostWithSig: [EIP712TypedDataField!]!
}

"The create post eip 712 typed data value"
type CreatePostEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  contentURI: PublicationUrl!
  collectModule: ContractAddress!
  collectModuleInitData: CollectModuleData!
  referenceModule: ContractAddress!
  referenceModuleInitData: ReferenceModuleData!
}

"The broadcast item"
type CreateSetDispatcherBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetDispatcherEIP712TypedData!
}

"The set dispatcher eip 712 typed data"
type CreateSetDispatcherEIP712TypedData {
  "The types"
  types: CreateSetDispatcherEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetDispatcherEIP712TypedDataValue!
}

"The set dispatcher eip 712 typed data types"
type CreateSetDispatcherEIP712TypedDataTypes {
  SetDispatcherWithSig: [EIP712TypedDataField!]!
}

"The set dispatcher eip 712 typed data value"
type CreateSetDispatcherEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  dispatcher: EthereumAddress!
}

"The broadcast item"
type CreateSetFollowModuleBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetFollowModuleEIP712TypedData!
}

"The set follow module eip 712 typed data"
type CreateSetFollowModuleEIP712TypedData {
  "The types"
  types: CreateSetFollowModuleEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetFollowModuleEIP712TypedDataValue!
}

"The set follow module eip 712 typed data types"
type CreateSetFollowModuleEIP712TypedDataTypes {
  SetFollowModuleWithSig: [EIP712TypedDataField!]!
}

"The set follow module eip 712 typed data value"
type CreateSetFollowModuleEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  followModule: ContractAddress!
  followModuleInitData: FollowModuleData!
}

"The broadcast item"
type CreateSetFollowNFTUriBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetFollowNFTUriEIP712TypedData!
}

"The set follow nft uri eip 712 typed data"
type CreateSetFollowNFTUriEIP712TypedData {
  "The types"
  types: CreateSetFollowNFTUriEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetFollowNFTUriEIP712TypedDataValue!
}

"The set follow nft uri eip 712 typed data types"
type CreateSetFollowNFTUriEIP712TypedDataTypes {
  SetFollowNFTURIWithSig: [EIP712TypedDataField!]!
}

"The set follow nft uri eip 712 typed data value"
type CreateSetFollowNFTUriEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  followNFTURI: Url!
}

"The broadcast item"
type CreateSetProfileImageUriBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetProfileImageUriEIP712TypedData!
}

"The set profile uri eip 712 typed data"
type CreateSetProfileImageUriEIP712TypedData {
  "The types"
  types: CreateSetProfileImageUriEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetProfileImageUriEIP712TypedDataValue!
}

"The set profile image uri eip 712 typed data types"
type CreateSetProfileImageUriEIP712TypedDataTypes {
  SetProfileImageURIWithSig: [EIP712TypedDataField!]!
}

"The set profile uri eip 712 typed data value"
type CreateSetProfileImageUriEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  imageURI: Url!
}

"The broadcast item"
type CreateSetProfileMetadataURIBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateSetProfileMetadataURIEIP712TypedData!
}

"The set follow nft uri eip 712 typed data"
type CreateSetProfileMetadataURIEIP712TypedData {
  "The types"
  types: CreateSetProfileMetadataURIEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateSetProfileMetadataURIEIP712TypedDataValue!
}

"The set follow nft uri eip 712 typed data types"
type CreateSetProfileMetadataURIEIP712TypedDataTypes {
  SetProfileMetadataURIWithSig: [EIP712TypedDataField!]!
}

"The set follow nft uri eip 712 typed data value"
type CreateSetProfileMetadataURIEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  metadata: Url!
}

"The broadcast item"
type CreateToggleFollowBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateToggleFollowEIP712TypedData!
}

"The create toggle follows eip 712 typed data"
type CreateToggleFollowEIP712TypedData {
  "The types"
  types: CreateToggleFollowEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: CreateToggleFollowEIP712TypedDataValue!
}

"The create toggle follows eip 712 typed data types"
type CreateToggleFollowEIP712TypedDataTypes {
  ToggleFollowWithSig: [EIP712TypedDataField!]!
}

"The create toggle follow eip 712 typed data value"
type CreateToggleFollowEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileIds: [ProfileId!]!
  enables: [Boolean!]!
}

"The broadcast item"
type CreateUnfollowBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: CreateBurnEIP712TypedData!
}

type DegreesOfSeparationReferenceModuleSettings {
  "The reference modules enum"
  type: ReferenceModules!
  contractAddress: ContractAddress!
  "Applied to comments"
  commentsRestricted: Boolean!
  "Applied to mirrors"
  mirrorsRestricted: Boolean!
  "Degrees of separation"
  degreesOfSeparation: Int!
}

"The dispatcher"
type Dispatcher {
  "The dispatcher address"
  address: EthereumAddress!
  "If the dispatcher can use the relay"
  canUseRelay: Boolean!
}

"The does follow response"
type DoesFollowResponse {
  "The follower address remember wallets follow profiles"
  followerAddress: EthereumAddress!
  "The profile id"
  profileId: ProfileId!
  "If the user does follow"
  follows: Boolean!
}

"The eip 712 typed data domain"
type EIP712TypedDataDomain {
  "The name of the typed data domain"
  name: String!
  "The chainId"
  chainId: ChainId!
  "The version"
  version: String!
  "The verifying contract"
  verifyingContract: ContractAddress!
}

"The eip 712 typed data field"
type EIP712TypedDataField {
  "The name of the typed data field"
  name: String!
  "The type of the typed data field"
  type: String!
}

type ElectedMirror {
  mirrorId: InternalPublicationId!
  profile: Profile!
  timestamp: DateTime!
}

type EnabledModule {
  moduleName: String!
  contractAddress: ContractAddress!
  inputParams: [ModuleInfo!]!
  redeemParams: [ModuleInfo!]!
  returnDataParms: [ModuleInfo!]!
}

"The enabled modules"
type EnabledModules {
  collectModules: [EnabledModule!]!
  followModules: [EnabledModule!]!
  referenceModules: [EnabledModule!]!
}

type EnsOnChainIdentity {
  "The default ens mapped to this address"
  name: Ens
}

"The erc20 type"
type Erc20 {
  "Name of the symbol"
  name: String!
  "Symbol for the token"
  symbol: String!
  "Decimal places for the token"
  decimals: Int!
  "The erc20 address"
  address: ContractAddress!
}

type Erc20Amount {
  "The erc20 token info"
  asset: Erc20!
  "Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal."
  value: String!
}

"The paginated publication result"
type ExploreProfileResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated publication result"
type ExplorePublicationResult {
  items: [Publication!]!
  pageInfo: PaginatedResultInfo!
}

type FeeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

type FeeFollowModuleSettings {
  "The follow modules enum"
  type: FollowModules!
  contractAddress: ContractAddress!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
}

type FeedItem {
  root: FeedItemRoot!
  "The elected mirror will be the first Mirror publication within the page results set"
  electedMirror: ElectedMirror
  "Sorted by most recent first. Up to page size - 1 mirrors"
  mirrors: [MirrorEvent!]!
  "Sorted by most recent first. Resolves defaultProfile and if null omits the wallet collect event from the list."
  collects: [CollectedEvent!]!
  "Sorted by most recent first. Up to page size - 1 reactions"
  reactions: [ReactionEvent!]!
  "Sorted by most recent first. Up to page size - 1 comments."
  comments: [Comment!]
}

type FollowOnlyReferenceModuleSettings {
  "The reference modules enum"
  type: ReferenceModules!
  contractAddress: ContractAddress!
}

type FollowRevenueResult {
  revenues: [RevenueAggregate!]!
}

type Follower {
  wallet: Wallet!
  totalAmountOfTimesFollowed: Int!
}

type FollowerNftOwnedTokenIds {
  followerNftAddress: ContractAddress!
  tokensIds: [String!]!
}

type Following {
  profile: Profile!
  totalAmountOfTimesFollowing: Int!
}

type FreeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "Follower only"
  followerOnly: Boolean!
}

type GenerateModuleCurrencyApproval {
  to: ContractAddress!
  from: EthereumAddress!
  data: BlockchainData!
}

type GlobalProtocolStats {
  totalProfiles: Int!
  totalBurntProfiles: Int!
  totalPosts: Int!
  totalMirrors: Int!
  totalComments: Int!
  totalCollects: Int!
  totalFollows: Int!
  totalRevenue: [Erc20Amount!]!
}

type LimitedFeeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "The collect module limit"
  collectLimit: String!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
}

type LimitedTimedFeeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "The collect module limit"
  collectLimit: String!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
  "The collect module end timestamp"
  endTimestamp: DateTime!
}

type Log {
  blockNumber: Int!
  blockHash: String!
  transactionIndex: Int!
  removed: Boolean!
  address: ContractAddress!
  data: String!
  topics: [String!]!
  transactionHash: TxHash!
  logIndex: Int!
}

"The Media url"
type Media {
  "The token image nft"
  url: Url!
  "Width - will always be null on the public API"
  width: Int
  "Height - will always be null on the public API"
  height: Int
  "Size - will always be null on the public API"
  size: Int
  "The image/audio/video mime type for the publication"
  mimeType: MimeType
  "The alt tags for accessibility"
  altTag: String
  "The cover for any video or audio you attached"
  cover: String
}

"The Media Set"
type MediaSet {
  "Original media"
  original: Media!
  "Small media - will always be null on the public API"
  small: Media @deprecated(reason: "should not be used will always be null")
  "Medium media - will always be null on the public API"
  medium: Media @deprecated(reason: "should not be used will always be null")
}

"The metadata attribute output"
type MetadataAttributeOutput {
  "The display type"
  displayType: PublicationMetadataDisplayTypes
  "The trait type - can be anything its the name it will render so include spaces"
  traitType: String
  "The value"
  value: String
}

"The metadata output"
type MetadataOutput {
  "The metadata name"
  name: String
  "This is the metadata description"
  description: Markdown
  "This is the metadata content for the publication, should be markdown"
  content: Markdown
  "This is the image attached to the metadata and the property used to show the NFT!"
  image: Url
  "The image cover for video/music publications"
  cover: MediaSet
  "The images/audios/videos for the publication"
  media: [MediaSet!]!
  "The attributes"
  attributes: [MetadataAttributeOutput!]!
  "The locale of the publication, "
  locale: Locale
  "The tags for the publication"
  tags: [String!]!
  "The content warning for the publication"
  contentWarning: PublicationContentWarning
  "The main focus of the publication"
  mainContentFocus: PublicationMainFocus!
  "The main focus of the publication"
  animatedUrl: Url
}

"The social mirror"
type Mirror {
  "The internal publication id"
  id: InternalPublicationId!
  "The profile ref"
  profile: Profile!
  "The publication stats"
  stats: PublicationStats!
  "The metadata for the post"
  metadata: MetadataOutput!
  "The on chain content uri could be `ipfs://` or `https`"
  onChainContentURI: String!
  "The date the post was created on"
  createdAt: DateTime!
  "The collect module"
  collectModule: CollectModule!
  "The reference module"
  referenceModule: ReferenceModule
  "ID of the source"
  appId: Sources
  "If the publication has been hidden if it has then the content and media is not available"
  hidden: Boolean!
  "The contract address for the collect nft.. if its null it means nobody collected yet as it lazy deployed"
  collectNftAddress: ContractAddress
  "The mirror publication"
  mirrorOf: MirrorablePublication!
  reaction(request: ReactionFieldResolverRequest): ReactionTypes
  hasCollectedByMe: Boolean!
  canComment(profileId: ProfileId): CanCommentResponse!
  canMirror(profileId: ProfileId): CanMirrorResponse!
}

type MirrorEvent {
  profile: Profile!
  timestamp: DateTime!
}

type ModuleFeeAmount {
  "The erc20 token info"
  asset: Erc20!
  "Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal."
  value: String!
}

type ModuleInfo {
  name: String!
  type: String!
}

type Mutation {
  authenticate(request: SignedAuthChallenge!): AuthenticationResult!
    @graphql(endpoint: "https://api.lens.dev")
  refresh(request: RefreshRequest!): AuthenticationResult!
    @graphql(endpoint: "https://api.lens.dev")
  broadcast(request: BroadcastRequest!): RelayResult!
    @graphql(endpoint: "https://api.lens.dev")
  createSetDispatcherTypedData(
    options: TypedDataOptions
    request: SetDispatcherRequest!
  ): CreateSetDispatcherBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createFollowTypedData(
    options: TypedDataOptions
    request: FollowRequest!
  ): CreateFollowBroadcastItemResult! @graphql(endpoint: "https://api.lens.dev")
  createUnfollowTypedData(
    options: TypedDataOptions
    request: UnfollowRequest!
  ): CreateUnfollowBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createSetFollowModuleTypedData(
    options: TypedDataOptions
    request: CreateSetFollowModuleRequest!
  ): CreateSetFollowModuleBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createSetFollowNFTUriTypedData(
    options: TypedDataOptions
    request: CreateSetFollowNFTUriRequest!
  ): CreateSetFollowNFTUriBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createToggleFollowTypedData(
    options: TypedDataOptions
    request: CreateToggleFollowRequest!
  ): CreateToggleFollowBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createCollectTypedData(
    options: TypedDataOptions
    request: CreateCollectRequest!
  ): CreateCollectBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createSetDefaultProfileTypedData(
    options: TypedDataOptions
    request: CreateSetDefaultProfileRequest!
  ): SetDefaultProfileBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createSetProfileImageURITypedData(
    options: TypedDataOptions
    request: UpdateProfileImageRequest!
  ): CreateSetProfileImageUriBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createSetProfileImageURIViaDispatcher(
    request: UpdateProfileImageRequest!
  ): RelayResult! @graphql(endpoint: "https://api.lens.dev")
  createBurnProfileTypedData(
    options: TypedDataOptions
    request: BurnProfileRequest!
  ): CreateBurnProfileBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createPostTypedData(
    options: TypedDataOptions
    request: CreatePublicPostRequest!
  ): CreatePostBroadcastItemResult! @graphql(endpoint: "https://api.lens.dev")
  createPostViaDispatcher(request: CreatePublicPostRequest!): RelayResult!
    @graphql(endpoint: "https://api.lens.dev")
  createCommentTypedData(
    options: TypedDataOptions
    request: CreatePublicCommentRequest!
  ): CreateCommentBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createCommentViaDispatcher(
    request: CreatePublicCommentRequest!
  ): RelayResult! @graphql(endpoint: "https://api.lens.dev")
  createMirrorTypedData(
    options: TypedDataOptions
    request: CreateMirrorRequest!
  ): CreateMirrorBroadcastItemResult! @graphql(endpoint: "https://api.lens.dev")
  hidePublication(request: HidePublicationRequest!): Void
    @graphql(endpoint: "https://api.lens.dev")
  createMirrorViaDispatcher(request: CreateMirrorRequest!): RelayResult!
    @graphql(endpoint: "https://api.lens.dev")
  claim(request: ClaimHandleRequest!): RelayResult!
    @graphql(endpoint: "https://api.lens.dev")
  createSetProfileMetadataTypedData(
    options: TypedDataOptions
    request: CreatePublicSetProfileMetadataURIRequest!
  ): CreateSetProfileMetadataURIBroadcastItemResult!
    @graphql(endpoint: "https://api.lens.dev")
  createSetProfileMetadataViaDispatcher(
    request: CreatePublicSetProfileMetadataURIRequest!
  ): RelayResult! @graphql(endpoint: "https://api.lens.dev")
  proxyAction(request: ProxyActionRequest!): ProxyActionId!
    @graphql(endpoint: "https://api.lens.dev")
  addReaction(request: ReactionRequest!): Void
    @graphql(endpoint: "https://api.lens.dev")
  removeReaction(request: ReactionRequest!): Void
    @graphql(endpoint: "https://api.lens.dev")
  reportPublication(request: ReportPublicationRequest!): Void
    @graphql(endpoint: "https://api.lens.dev")
  ach(request: AchRequest!): Void @graphql(endpoint: "https://api.lens.dev")
}

"The nft type"
type NFT {
  "aka us CryptoKitties"
  contractName: String!
  "aka 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e "
  contractAddress: ContractAddress!
  "aka RARI"
  symbol: String!
  "aka \"13\" "
  tokenId: String!
  "aka { address: 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e, amount:\"2\" } "
  owners: [Owner!]!
  "aka \"Beard Coffee\" "
  name: String!
  "aka \"Hey cutie! I m Beard Coffee. .... "
  description: String!
  "aka \"https://api.criptokitt...\" "
  contentURI: String!
  "aka \"{ uri:\"https://ipfs....\", metaType:\"image/png\" }\" "
  originalContent: NFTContent!
  "aka \"1\" "
  chainId: ChainId!
  "aka \"CryptoKitties\" "
  collectionName: String!
  "aka \"ERC721\" "
  ercType: String!
}

"The NFT content uri"
type NFTContent {
  "The token uri  nft"
  uri: String!
  "The meta type content"
  metaType: String!
  "The animated url"
  animatedUrl: String
}

"Paginated nft results"
type NFTsResult {
  items: [NFT!]!
  pageInfo: PaginatedResultInfo!
}

type NewCollectNotification {
  notificationId: NotificationId!
  createdAt: DateTime!
  wallet: Wallet!
  collectedPublication: Publication!
}

type NewCommentNotification {
  notificationId: NotificationId!
  createdAt: DateTime!
  "The profile"
  profile: Profile!
  comment: Comment!
}

type NewFollowerNotification {
  notificationId: NotificationId!
  createdAt: DateTime!
  wallet: Wallet!
  isFollowedByMe: Boolean!
}

type NewMentionNotification {
  notificationId: NotificationId!
  createdAt: DateTime!
  mentionPublication: MentionPublication!
}

type NewMirrorNotification {
  notificationId: NotificationId!
  createdAt: DateTime!
  "The profile"
  profile: Profile!
  publication: MirrorablePublication!
}

type NewReactionNotification {
  notificationId: NotificationId!
  createdAt: DateTime!
  "The profile"
  profile: Profile!
  reaction: ReactionTypes!
  publication: Publication!
}

"The NFT image"
type NftImage {
  "The contract address"
  contractAddress: ContractAddress!
  "The token id of the nft"
  tokenId: String!
  "The token image nft"
  uri: Url!
  "The token image nft"
  chainId: Int!
  "If the NFT is verified"
  verified: Boolean!
}

"NFT ownership challenge result"
type NftOwnershipChallengeResult {
  "Id of the nft ownership challenge"
  id: NftOwnershipId!
  text: String!
  "Timeout of the validation"
  timeout: TimestampScalar!
}

type OnChainIdentity {
  "The POH status"
  proofOfHumanity: Boolean!
  "The ens information"
  ens: EnsOnChainIdentity
  "The sybil dot org information"
  sybilDotOrg: SybilDotOrgIdentity!
  "The worldcoin identity"
  worldcoin: WorldcoinIdentity!
}

"The nft type"
type Owner {
  "number of tokens owner"
  amount: Float!
  "aka 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e "
  address: EthereumAddress!
}

"The paginated wallet result"
type PaginatedAllPublicationsTagsResult {
  items: [TagResult!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated feed result"
type PaginatedFeedResult {
  items: [FeedItem!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated followers result"
type PaginatedFollowersResult {
  items: [Follower!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFollowingResult {
  items: [Following!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated notification result"
type PaginatedNotificationResult {
  items: [Notification!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated wallet result"
type PaginatedProfilePublicationsForSaleResult {
  items: [PublicationForSale!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated profile result"
type PaginatedProfileResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated publication result"
type PaginatedPublicationResult {
  items: [Publication!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated result info"
type PaginatedResultInfo {
  "Cursor to query the actual results"
  prev: Cursor
  "Cursor to query next results"
  next: Cursor
  "The total number of entities the pagination iterates over. If null it means it can not work it out due to dynamic or aggregated query e.g. For a query that requests all nfts with more than 10 likes, this field gives the total amount of nfts with more than 10 likes, not the total amount of nfts"
  totalCount: Int
}

"The paginated timeline result"
type PaginatedTimelineResult {
  items: [Publication!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated wallet result"
type PaginatedWhoCollectedResult {
  items: [Wallet!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedWhoReactedResult {
  items: [WhoReactedResult!]!
  pageInfo: PaginatedResultInfo!
}

"The paginated follow result"
type PendingApproveFollowsResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
}

"The social post"
type Post {
  "The internal publication id"
  id: InternalPublicationId!
  "The profile ref"
  profile: Profile!
  "The publication stats"
  stats: PublicationStats!
  "The metadata for the post"
  metadata: MetadataOutput!
  "The on chain content uri could be `ipfs://` or `https`"
  onChainContentURI: String!
  "The date the post was created on"
  createdAt: DateTime!
  "The collect module"
  collectModule: CollectModule!
  "The reference module"
  referenceModule: ReferenceModule
  "ID of the source"
  appId: Sources
  "If the publication has been hidden if it has then the content and media is not available"
  hidden: Boolean!
  "The contract address for the collect nft.. if its null it means nobody collected yet as it lazy deployed"
  collectNftAddress: ContractAddress
  "Who collected it, this is used for timeline results and like this for better caching for the client"
  collectedBy: Wallet
    @deprecated(
      reason: "use `feed` query, timeline query will be killed on the 15th November. This includes this field."
    )
  reaction(request: ReactionFieldResolverRequest): ReactionTypes
  hasCollectedByMe: Boolean!
  canComment(profileId: ProfileId): CanCommentResponse!
  canMirror(profileId: ProfileId): CanMirrorResponse!
  mirrors(by: ProfileId): [InternalPublicationId!]!
}

"The Profile"
type Profile {
  "The profile id"
  id: ProfileId!
  "Name of the profile"
  name: String
  "Bio of the profile"
  bio: String
  "Follow nft address"
  followNftAddress: ContractAddress
  "Metadata url"
  metadata: Url
  "The profile handle"
  handle: Handle!
  "The picture for the profile"
  picture: ProfileMedia
  "The cover picture for the profile"
  coverPicture: ProfileMedia
  "Who owns the profile"
  ownedBy: EthereumAddress!
  "The dispatcher"
  dispatcher: Dispatcher
  "Profile stats"
  stats: ProfileStats!
  "The follow module"
  followModule: FollowModule
  "Is the profile default"
  isDefault: Boolean!
  "Optionals param to add extra attributes on the metadata"
  attributes: [Attribute!]
  "The on chain identity"
  onChainIdentity: OnChainIdentity!
  isFollowedByMe: Boolean!
  isFollowing(who: ProfileId): Boolean!
}

type ProfileFollowModuleSettings {
  "The follow module enum"
  type: FollowModules!
  contractAddress: ContractAddress!
}

"The paginated revenue result"
type ProfilePublicationRevenueResult {
  items: [PublicationRevenue!]!
  pageInfo: PaginatedResultInfo!
}

"Profile search results"
type ProfileSearchResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
  type: SearchRequestTypes!
}

"The Profile Stats"
type ProfileStats {
  id: ProfileId!
  "Total follower count"
  totalFollowers: Int!
  "Total following count (remember the wallet follows not profile so will be same for every profile they own)"
  totalFollowing: Int!
  "Total post count"
  totalPosts: Int!
  "Total comment count"
  totalComments: Int!
  "Total mirror count"
  totalMirrors: Int!
  "Total publication count"
  totalPublications: Int!
  "Total collects count"
  totalCollects: Int!
  commentsTotal(forSources: [Sources!]!): Int!
  postsTotal(forSources: [Sources!]!): Int!
  mirrorsTotal(forSources: [Sources!]!): Int!
  publicationsTotal(forSources: [Sources!]!): Int!
}

type ProxyActionError {
  reason: String!
  lastKnownTxId: TxId
}

type ProxyActionQueued {
  queuedAt: DateTime!
}

type ProxyActionStatusResult {
  txHash: TxHash!
  txId: TxId!
  status: ProxyActionStatusTypes!
}

type PublicationMetadataStatus {
  status: PublicationMetadataStatusType!
  "If metadata validation failed it will put a reason why here"
  reason: String
}

"The social comment"
type PublicationRevenue {
  publication: Publication!
  revenue: RevenueAggregate!
}

"Publication search results"
type PublicationSearchResult {
  items: [PublicationSearchResultItem!]!
  pageInfo: PaginatedResultInfo!
  type: SearchRequestTypes!
}

"The publication stats"
type PublicationStats {
  "The publication id"
  id: InternalPublicationId!
  "The total amount of mirrors"
  totalAmountOfMirrors: Int!
  "The total amount of collects"
  totalAmountOfCollects: Int!
  "The total amount of comments"
  totalAmountOfComments: Int!
  "The total amount of downvotes"
  totalUpvotes: Int!
  "The total amount of upvotes"
  totalDownvotes: Int!
  commentsTotal(forSources: [Sources!]!): Int!
}

type PublicationValidateMetadataResult {
  valid: Boolean!
  "If `valid` is false it will put a reason why here"
  reason: String
}

type Query {
  challenge(request: ChallengeRequest!): AuthChallengeResult!
    @graphql(endpoint: "https://api.lens.dev")
  verify(request: VerifyRequest!): Boolean!
    @graphql(endpoint: "https://api.lens.dev")
  txIdToTxHash(txId: TxId!): TxHash! @graphql(endpoint: "https://api.lens.dev")
  explorePublications(
    request: ExplorePublicationRequest!
  ): ExplorePublicationResult! @graphql(endpoint: "https://api.lens.dev")
  exploreProfiles(request: ExploreProfilesRequest!): ExploreProfileResult!
    @graphql(endpoint: "https://api.lens.dev")
  feed(request: FeedRequest!): PaginatedFeedResult!
    @graphql(endpoint: "https://api.lens.dev")
  feedHighlights(request: FeedHighlightsRequest!): PaginatedTimelineResult!
    @graphql(endpoint: "https://api.lens.dev")
  timeline(request: TimelineRequest!): PaginatedTimelineResult!
    @deprecated(
      reason: "You should be using feed, this will not be supported after 15th November 2021, please migrate."
    )
    @graphql(endpoint: "https://api.lens.dev")
  pendingApprovalFollows(
    request: PendingApprovalFollowsRequest!
  ): PendingApproveFollowsResult! @graphql(endpoint: "https://api.lens.dev")
  doesFollow(request: DoesFollowRequest!): [DoesFollowResponse!]!
    @graphql(endpoint: "https://api.lens.dev")
  following(request: FollowingRequest!): PaginatedFollowingResult!
    @graphql(endpoint: "https://api.lens.dev")
  followers(request: FollowersRequest!): PaginatedFollowersResult!
    @graphql(endpoint: "https://api.lens.dev")
  followerNftOwnedTokenIds(
    request: FollowerNftOwnedTokenIdsRequest!
  ): FollowerNftOwnedTokenIds @graphql(endpoint: "https://api.lens.dev")
  mutualFollowersProfiles(
    request: MutualFollowersProfilesQueryRequest!
  ): PaginatedProfileResult! @graphql(endpoint: "https://api.lens.dev")
  ping: String! @graphql(endpoint: "https://api.lens.dev")
  hasTxHashBeenIndexed(
    request: HasTxHashBeenIndexedRequest!
  ): TransactionResult! @graphql(endpoint: "https://api.lens.dev")
  enabledModuleCurrencies: [Erc20!]! @graphql(endpoint: "https://api.lens.dev")
  approvedModuleAllowanceAmount(
    request: ApprovedModuleAllowanceAmountRequest!
  ): [ApprovedAllowanceAmount!]! @graphql(endpoint: "https://api.lens.dev")
  generateModuleCurrencyApprovalData(
    request: GenerateModuleCurrencyApprovalDataRequest!
  ): GenerateModuleCurrencyApproval! @graphql(endpoint: "https://api.lens.dev")
  profileFollowModuleBeenRedeemed(
    request: ProfileFollowModuleBeenRedeemedRequest!
  ): Boolean! @graphql(endpoint: "https://api.lens.dev")
  enabledModules: EnabledModules! @graphql(endpoint: "https://api.lens.dev")
  unknownEnabledModules: EnabledModules!
    @graphql(endpoint: "https://api.lens.dev")
  nfts(request: NFTsRequest!): NFTsResult!
    @graphql(endpoint: "https://api.lens.dev")
  nftOwnershipChallenge(
    request: NftOwnershipChallengeRequest!
  ): NftOwnershipChallengeResult! @graphql(endpoint: "https://api.lens.dev")
  notifications(request: NotificationRequest!): PaginatedNotificationResult!
    @graphql(endpoint: "https://api.lens.dev")
  profiles(request: ProfileQueryRequest!): PaginatedProfileResult!
    @graphql(endpoint: "https://api.lens.dev")
  profile(request: SingleProfileQueryRequest!): Profile
    @graphql(endpoint: "https://api.lens.dev")
  recommendedProfiles(options: RecommendedProfileOptions): [Profile!]!
    @graphql(endpoint: "https://api.lens.dev")
  defaultProfile(request: DefaultProfileRequest!): Profile
    @graphql(endpoint: "https://api.lens.dev")
  globalProtocolStats(
    request: GlobalProtocolStatsRequest
  ): GlobalProtocolStats! @graphql(endpoint: "https://api.lens.dev")
  publications(request: PublicationsQueryRequest!): PaginatedPublicationResult!
    @graphql(endpoint: "https://api.lens.dev")
  publication(request: PublicationQueryRequest!): Publication
    @graphql(endpoint: "https://api.lens.dev")
  whoCollectedPublication(
    request: WhoCollectedPublicationRequest!
  ): PaginatedWhoCollectedResult! @graphql(endpoint: "https://api.lens.dev")
  profilePublicationsForSale(
    request: ProfilePublicationsForSaleRequest!
  ): PaginatedProfilePublicationsForSaleResult!
    @graphql(endpoint: "https://api.lens.dev")
  allPublicationsTags(
    request: AllPublicationsTagsRequest!
  ): PaginatedAllPublicationsTagsResult!
    @graphql(endpoint: "https://api.lens.dev")
  search(request: SearchQueryRequest!): SearchResult!
    @graphql(endpoint: "https://api.lens.dev")
  userSigNonces: UserSigNonces! @graphql(endpoint: "https://api.lens.dev")
  claimableHandles: ClaimableHandles! @graphql(endpoint: "https://api.lens.dev")
  internalPublicationFilter(
    request: InternalPublicationsFilterRequest!
  ): PaginatedPublicationResult! @graphql(endpoint: "https://api.lens.dev")
  profileOnChainIdentity(
    request: ProfileOnChainIdentityRequest!
  ): [OnChainIdentity!]! @graphql(endpoint: "https://api.lens.dev")
  proxyActionStatus(
    proxyActionId: ProxyActionId!
  ): ProxyActionStatusResultUnion! @graphql(endpoint: "https://api.lens.dev")
  validatePublicationMetadata(
    request: ValidatePublicationMetadataRequest!
  ): PublicationValidateMetadataResult!
    @graphql(endpoint: "https://api.lens.dev")
  publicationMetadataStatus(
    request: GetPublicationMetadataStatusRequest!
  ): PublicationMetadataStatus! @graphql(endpoint: "https://api.lens.dev")
  whoReactedPublication(
    request: WhoReactedPublicationRequest!
  ): PaginatedWhoReactedResult! @graphql(endpoint: "https://api.lens.dev")
  profilePublicationRevenue(
    request: ProfilePublicationRevenueQueryRequest!
  ): ProfilePublicationRevenueResult! @graphql(endpoint: "https://api.lens.dev")
  publicationRevenue(
    request: PublicationRevenueQueryRequest!
  ): PublicationRevenue @graphql(endpoint: "https://api.lens.dev")
  profileFollowRevenue(
    request: ProfileFollowRevenueQueryRequest!
  ): FollowRevenueResult! @graphql(endpoint: "https://api.lens.dev")
  rel(request: RelRequest!): Void @graphql(endpoint: "https://api.lens.dev")
}

type ReactionEvent {
  profile: Profile!
  reaction: ReactionTypes!
  timestamp: DateTime!
}

type RelayError {
  reason: RelayErrorReasons!
}

"The relayer result"
type RelayerResult {
  "The tx hash - you should use the `txId` as your identifier as gas prices can be upgraded meaning txHash will change"
  txHash: TxHash!
  "The tx id"
  txId: TxId!
}

type ReservedClaimableHandle {
  id: HandleClaimIdScalar!
  handle: Handle!
  source: String!
  expiry: DateTime!
}

type RevenueAggregate {
  total: Erc20Amount!
}

type RevertCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
}

type RevertFollowModuleSettings {
  "The follow module enum"
  type: FollowModules!
  contractAddress: ContractAddress!
}

"The broadcast item"
type SetDefaultProfileBroadcastItemResult {
  "This broadcast item ID"
  id: BroadcastId!
  "The date the broadcast item expiries"
  expiresAt: DateTime!
  "The typed data"
  typedData: SetDefaultProfileEIP712TypedData!
}

"The default profile eip 712 typed data"
type SetDefaultProfileEIP712TypedData {
  "The types"
  types: SetDefaultProfileEIP712TypedDataTypes!
  "The typed data domain"
  domain: EIP712TypedDataDomain!
  "The values"
  value: SetDefaultProfileEIP712TypedDataValue!
}

"The default profile eip 712 typed data types"
type SetDefaultProfileEIP712TypedDataTypes {
  SetDefaultProfileWithSig: [EIP712TypedDataField!]!
}

"The default profile eip 712 typed data value"
type SetDefaultProfileEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  wallet: EthereumAddress!
  profileId: ProfileId!
}

type SybilDotOrgIdentity {
  "The sybil dot org status"
  verified: Boolean!
  source: SybilDotOrgIdentitySource!
}

type SybilDotOrgIdentitySource {
  twitter: SybilDotOrgTwitterIdentity!
}

type SybilDotOrgTwitterIdentity {
  handle: String
}

"The social comment"
type TagResult {
  "The tag"
  tag: PublicationTag!
  "The total amount of publication tagged"
  total: Int!
}

type TimedFeeCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "The collect module amount info"
  amount: ModuleFeeAmount!
  "The collect module recipient address"
  recipient: EthereumAddress!
  "The collect module referral fee"
  referralFee: Float!
  "Follower only"
  followerOnly: Boolean!
  "The collect module end timestamp"
  endTimestamp: DateTime!
}

type TransactionError {
  reason: TransactionErrorReasons!
  txReceipt: TransactionReceipt
}

type TransactionIndexedResult {
  indexed: Boolean!
  txHash: TxHash!
  txReceipt: TransactionReceipt
  "Publications can be indexed but the ipfs link for example not findable for x time. This allows you to work that out for publications. If its not a publication tx then it always be null."
  metadataStatus: PublicationMetadataStatus
}

type TransactionReceipt {
  to: EthereumAddress
  from: EthereumAddress!
  contractAddress: ContractAddress
  transactionIndex: Int!
  root: String
  gasUsed: String!
  logsBloom: String!
  blockHash: String!
  transactionHash: TxHash!
  logs: [Log!]!
  blockNumber: Int!
  confirmations: Int!
  cumulativeGasUsed: String!
  effectiveGasPrice: String!
  byzantium: Boolean!
  type: Int!
  status: Int
}

type UnknownCollectModuleSettings {
  "The collect modules enum"
  type: CollectModules!
  contractAddress: ContractAddress!
  "The data used to setup the module which you can decode with your known ABI "
  collectModuleReturnData: CollectModuleData!
}

type UnknownFollowModuleSettings {
  "The follow modules enum"
  type: FollowModules!
  contractAddress: ContractAddress!
  "The data used to setup the module which you can decode with your known ABI "
  followModuleReturnData: FollowModuleData!
}

type UnknownReferenceModuleSettings {
  "The reference modules enum"
  type: ReferenceModules!
  contractAddress: ContractAddress!
  "The data used to setup the module which you can decode with your known ABI "
  referenceModuleReturnData: ReferenceModuleData!
}

type UserSigNonces {
  lensHubOnChainSigNonce: Nonce!
  peripheryOnChainSigNonce: Nonce!
}

type Wallet {
  address: EthereumAddress!
  "The default profile for the wallet for now it is just their first profile, this will be the default profile they picked soon enough"
  defaultProfile: Profile
}

"The Profile"
type WhoReactedResult {
  "The reaction id"
  reactionId: ReactionId!
  "The reaction"
  reaction: ReactionTypes!
  "The reaction"
  reactionAt: DateTime!
  profile: Profile!
}

type WorldcoinIdentity {
  "If the profile has verified as a user"
  isHuman: Boolean!
}
